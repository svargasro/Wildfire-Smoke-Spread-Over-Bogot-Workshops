# -*- coding: utf-8 -*-
"""Ejercicio2-c

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hqVO0e1_vE1KXerGhe7maDkFXHlg21fW
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import scipy as sci
import math

#Número de filas del archivo de datos del punto 2b
Tamaño=1491
#l: Arreglo con la información de λ
l=np.zeros(Tamaño)
#f_l: Arreglo con la información de f(λ)
f_l=np.zeros(Tamaño)

#Importamos los datos
f = open('datos_b.dat', 'r')
i=0
for line in f:
    line = line.strip()
    columns = line.split()
    l[i] = float(columns[0])
    f_l[i] = float(columns[1])
    i+=1
f.close()

#Esta función nos devuelve el i-ésimo término del arreglo l asociado a un valor del dominio λ ([0.1,15])
def i(x):
  return int((x-0.1)*100)

#Con dos valores del dominio A, B, esta función halla el valor M para el cual f(M) se hace cero con cierto error
def CeroPorBiseccion(data_y, A, B, Err):
  a=i(A)
  b=i(B)
  while B-A>Err:
    M=(A+B)/2
    m=i(M)
    if (data_y[a]*data_y[m])>0:
      A=M
    else:
      B=M
  return M

#Usando RK4, esta función soluciona la ecuación diferencial de Bessel que depende de λ y la grafica
def Graficar_RK4_Bessel(Lambda):
  #RK4 para sistemas acoplados
  #Primera derivada
  def f1(r,DR,R):
    return DR
  #Segunda derivada
  def f2(r,DR,R):
    return -DR/r-(Lambda**2)*R

  #Elegimos dr
  dr=0.01

  #Dominio: [r0, rf]
  r0=0.01
  rf=1.0

  #Hallamos el número de pasos que se tiene que repetir el proceso hasta que se aplique RK4 con r=rf
  NPasos=int((rf-r0)/dr)+1

  #Declaramos los arreglos que contienen la información de r, R, DR
  r=np.zeros(NPasos)
  R=np.zeros(NPasos)
  DR=np.zeros(NPasos)

  #Inicializamos los primeros valores del arreglo
  r[0]=r0
  R[0]=1
  DR[0]=0

  #En este loop resolvemos la ecuación diferencial aplicando RK4
  for i in range(NPasos-1):
    #RK4 para sistemas acoplados
    #K_R: Coeficientes asociados a la primera derivada
    #K_DR: Coeficientes asociados a la segunda derivada
    K1_R=dr*f1(r[i],DR[i],R[i])
    K1_DR=dr*f2(r[i],DR[i],R[i])

    K2_R=dr*f1(r[i]+dr/2,DR[i]+K1_DR/2,R[i]+K1_R/2)
    K2_DR=dr*f2(r[i]+dr/2,DR[i]+K1_DR/2,R[i]+K1_R/2)

    K3_R=dr*f1(r[i]+dr/2,DR[i]+K2_DR/2,R[i]+K2_R/2)
    K3_DR=dr*f2(r[i]+dr/2,DR[i]+K2_DR/2,R[i]+K2_R/2)

    K4_R=dr*f1(r[i]+dr,DR[i]+K3_DR,R[i]+K3_R)
    K4_DR=dr*f2(r[i]+dr,DR[i]+K3_DR,R[i]+K3_R)

    #Actualizamos las variables
    R[i+1]=R[i]+(K1_R+2*K2_R+2*K3_R+K4_R)/6
    DR[i+1]=DR[i]+(K1_DR+2*K2_DR+2*K3_DR+K4_DR)/6
    r[i+1]=r[i]+dr

  #Graficamos R(r) con una leyenda que contiene el valor de λ usado acotado a tres decimales
  plt.plot(r,R, label=(u"λ={}".format(round(Lambda,3))))
  plt.legend(fontsize="16")

#Esta función grafica los modos normales R(r) que no dependen de la coordenada angular 𝜃,
#para ello halla los ceros de los datos del punto 2b y los usa como los λ_i que tienen asociados
#cada uno una solución de la ecuación diferencial de Bessel, y superpone las gráficas
def Graficador_modos_normales(data_x, data_y, N, Err):
  #Arreglo que contiene los λ_i
  Lambda=np.zeros(N-1)

  #Arreglo que contiene los puntos que se obtienen de particionar el dominio en N-1 partes
  #(cada parte para cada cero a hallar en los datos del punto 2b)
  Particion=np.linspace(data_x[0], data_x[-1], N)

  #Título de la gráfica y sus ejes, y su tamaño
  fig = plt.figure(figsize=(17, 10.5))
  plt.title('MODOS NORMALES (RK4)', fontsize=20)
  plt.xlabel('$r$', fontsize=15)
  plt.ylabel('$R_λ(r)$', fontsize=15)

  #En este loop hallamos cada λ_i yendo por cada una de las particiones del dominio y graficamos la
  #solución de la ecuación de Bessel asociada a cada λ_i
  for i in range(N-1):
    Lambda[i]=CeroPorBiseccion(data_y, Particion[i], Particion[i+1], Err)
    Graficar_RK4_Bessel(Lambda[i])

  #Guardamos y cerramos la gráfica
  plt.savefig('Grafica_2c.png')
  plt.close()

#Usamos la función anterior para graficar todos los modos normales
Graficador_modos_normales(l, f_l, 6, 0.01)
