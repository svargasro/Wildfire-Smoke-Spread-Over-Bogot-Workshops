# -*- coding: utf-8 -*-
"""Ejercicio2-c

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hqVO0e1_vE1KXerGhe7maDkFXHlg21fW
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import scipy as sci
import math

#N煤mero de filas del archivo de datos del punto 2b
Tama帽o=1491
#l: Arreglo con la informaci贸n de 位
l=np.zeros(Tama帽o)
#f_l: Arreglo con la informaci贸n de f(位)
f_l=np.zeros(Tama帽o)

#Importamos los datos
f = open('datos_b.dat', 'r')
i=0
for line in f:
    line = line.strip()
    columns = line.split()
    l[i] = float(columns[0])
    f_l[i] = float(columns[1])
    i+=1
f.close()

#Esta funci贸n nos devuelve el i-茅simo t茅rmino del arreglo l asociado a un valor del dominio 位 ([0.1,15])
def i(x):
  return int((x-0.1)*100)

#Con dos valores del dominio A, B, esta funci贸n halla el valor M para el cual f(M) se hace cero con cierto error
def CeroPorBiseccion(data_y, A, B, Err):
  a=i(A)
  b=i(B)
  while B-A>Err:
    M=(A+B)/2
    m=i(M)
    if (data_y[a]*data_y[m])>0:
      A=M
    else:
      B=M
  return M

#Usando RK4, esta funci贸n soluciona la ecuaci贸n diferencial de Bessel que depende de 位 y la grafica
def Graficar_RK4_Bessel(Lambda):
  #RK4 para sistemas acoplados
  #Primera derivada
  def f1(r,DR,R):
    return DR
  #Segunda derivada
  def f2(r,DR,R):
    return -DR/r-(Lambda**2)*R

  #Elegimos dr
  dr=0.01

  #Dominio: [r0, rf]
  r0=0.01
  rf=1.0

  #Hallamos el n煤mero de pasos que se tiene que repetir el proceso hasta que se aplique RK4 con r=rf
  NPasos=int((rf-r0)/dr)+1

  #Declaramos los arreglos que contienen la informaci贸n de r, R, DR
  r=np.zeros(NPasos)
  R=np.zeros(NPasos)
  DR=np.zeros(NPasos)

  #Inicializamos los primeros valores del arreglo
  r[0]=r0
  R[0]=1
  DR[0]=0

  #En este loop resolvemos la ecuaci贸n diferencial aplicando RK4
  for i in range(NPasos-1):
    #RK4 para sistemas acoplados
    #K_R: Coeficientes asociados a la primera derivada
    #K_DR: Coeficientes asociados a la segunda derivada
    K1_R=dr*f1(r[i],DR[i],R[i])
    K1_DR=dr*f2(r[i],DR[i],R[i])

    K2_R=dr*f1(r[i]+dr/2,DR[i]+K1_DR/2,R[i]+K1_R/2)
    K2_DR=dr*f2(r[i]+dr/2,DR[i]+K1_DR/2,R[i]+K1_R/2)

    K3_R=dr*f1(r[i]+dr/2,DR[i]+K2_DR/2,R[i]+K2_R/2)
    K3_DR=dr*f2(r[i]+dr/2,DR[i]+K2_DR/2,R[i]+K2_R/2)

    K4_R=dr*f1(r[i]+dr,DR[i]+K3_DR,R[i]+K3_R)
    K4_DR=dr*f2(r[i]+dr,DR[i]+K3_DR,R[i]+K3_R)

    #Actualizamos las variables
    R[i+1]=R[i]+(K1_R+2*K2_R+2*K3_R+K4_R)/6
    DR[i+1]=DR[i]+(K1_DR+2*K2_DR+2*K3_DR+K4_DR)/6
    r[i+1]=r[i]+dr

  #Graficamos R(r) con una leyenda que contiene el valor de 位 usado acotado a tres decimales
  plt.plot(r,R, label=(u"位={}".format(round(Lambda,3))))
  plt.legend(fontsize="16")

#Esta funci贸n grafica los modos normales R(r) que no dependen de la coordenada angular ,
#para ello halla los ceros de los datos del punto 2b y los usa como los 位_i que tienen asociados
#cada uno una soluci贸n de la ecuaci贸n diferencial de Bessel, y superpone las gr谩ficas
def Graficador_modos_normales(data_x, data_y, N, Err):
  #Arreglo que contiene los 位_i
  Lambda=np.zeros(N-1)

  #Arreglo que contiene los puntos que se obtienen de particionar el dominio en N-1 partes
  #(cada parte para cada cero a hallar en los datos del punto 2b)
  Particion=np.linspace(data_x[0], data_x[-1], N)

  #T铆tulo de la gr谩fica y sus ejes, y su tama帽o
  fig = plt.figure(figsize=(17, 10.5))
  plt.title('MODOS NORMALES (RK4)', fontsize=20)
  plt.xlabel('$r$', fontsize=15)
  plt.ylabel('$R_位(r)$', fontsize=15)

  #En este loop hallamos cada 位_i yendo por cada una de las particiones del dominio y graficamos la
  #soluci贸n de la ecuaci贸n de Bessel asociada a cada 位_i
  for i in range(N-1):
    Lambda[i]=CeroPorBiseccion(data_y, Particion[i], Particion[i+1], Err)
    Graficar_RK4_Bessel(Lambda[i])

  #Guardamos y cerramos la gr谩fica
  plt.savefig('Grafica_2c.png')
  plt.close()

#Usamos la funci贸n anterior para graficar todos los modos normales
Graficador_modos_normales(l, f_l, 6, 0.01)
