# -*- coding: utf-8 -*-
"""Ejercicio2-d

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bcthC3uLPGMkPZk4Hw2_a-Uqv_gS83kq
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from scipy import integrate

#Factor de amplificaci贸n
#La gr谩ficas que vienen con el c贸digo usaron FA=10000
FA=100

#La soluci贸n general de la ecuaci贸n diferencial planteada en el ejercicio 2 es la funci贸n de Bessel para n=0 de 位*r
#R_位(r)=J_0(位*r)
def Bessel(n,l,r):
  t=np.linspace(0, np.pi, FA)
  return (1/np.pi)*integrate.simpson(np.cos(n*t-l*r*np.sin(t)), t)

#l: Arreglo con la informaci贸n de 位
l=np.linspace(0, 15.0, 15*FA)
#f_l: Arreglo con la informaci贸n de f(位)
f_l=np.zeros(len(l))
#f(位)=R(r=1;位)=J_0(位)
for i in range(len(l)):
  f_l[i]=Bessel(0, l[i], 1)

#Creamos y guardamos la gr谩fica de (位, f(位))
fig = plt.figure(figsize=(17, 10.5))
plt.title('Solucion teorica de f(位)', fontsize=20)
plt.xlabel('$位$', fontsize=15)
plt.ylabel('$f(位)=J_0(位)$', fontsize=15)
plt.plot(l, f_l)
plt.savefig('Grafica_2d1.png')
plt.close()

#Esta funci贸n nos devuelve el i-茅simo t茅rmino del arreglo l asociado a un valor del dominio 位 ([0,15])
def i(x):
  return int(x*FA)

#Con dos valores del dominio A, B, esta funci贸n halla el valor M para el cual f(M) se hace cero con cierto error
def CeroPorBiseccion(data, A, B, Err):
  a=i(A)
  b=i(B)
  while B-A>Err:
    M=(A+B)/2
    m=i(M)
    if (data[a]*data[m])>0:
      A=M
    else:
      B=M
  return M

#Esta funci贸n grafica la funci贸n de Bessel para un determinado 位_i
def Graficar_integral_Bessel(Lambda_i):
  #Dominio: [0, 10.0]
  r=np.linspace(0, 10.0, 10*FA)

  #Funci贸n de Bessel evaluada en cada punto del dominio (rango)
  Bessel_plot=np.zeros(len(r))
  for i in range(len(r)):
    Bessel_plot[i]=Bessel(0, Lambda_i, r[i])

  #Graficamos J_0(位*r) con una leyenda que contiene el valor de 位 usado acotado a tres decimales
  plt.plot(r, Bessel_plot, label=(u"位={}".format(round(Lambda_i,3))))
  plt.legend(fontsize="16")

#Esta funci贸n grafica los modos normales que no dependen de la coordenada angular , para ello
#halla los ceros de f(位) cuya soluci贸n te贸rica fue hallada anteriormente y los usa como los 位_i que
#tienen asociados cada uno la funci贸n de Bessel J_0(位_i*r), y superpone las gr谩ficas
def Graficador_modos_normales(data_x, data_y, N, Err):
  #Arreglo que contiene los 位_i
  Lambda=np.zeros(N-1)

  #Arreglo que contiene los puntos que se obtienen de particionar el dominio en N-1 partes
  #(cada parte para cada cero a hallar en f(位))
  Particion=np.linspace(data_x[0], data_x[-1], N)

  #T铆tulo de la gr谩fica y sus ejes, y su tama帽o
  fig = plt.figure(figsize=(17, 10.5))
  plt.title('MODOS NORMALES (BESSEL)', fontsize=20)
  plt.xlabel('$r$', fontsize=15)
  plt.ylabel('$J_0(位 \cdot r)$', fontsize=15)

  #En este loop hallamos cada 位_i yendo por cada una de las particiones del dominio y graficamos su soluci贸n asociada
  for i in range(N-1):
    Lambda[i]=CeroPorBiseccion(data_y, Particion[i], Particion[i+1], Err)
    Graficar_integral_Bessel(Lambda[i])

  #Guardamos y cerramos la gr谩fica
  plt.savefig('Grafica_2d2.png')
  plt.close()

#Usamos la funci贸n anterior para graficar todos los modos normales
Graficador_modos_normales(l, f_l, 6, 0.001)
